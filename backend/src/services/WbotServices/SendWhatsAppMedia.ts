import { WASocket } from "@whiskeysockets/baileys";
import { getWbot } from "../../libs/wbot";
import AppError from "../../errors/AppError";
import GetTicketWbot from "../../helpers/GetTicketWbot";
import Ticket from "../../models/Ticket";
import Message from "../../models/Message";
import CreateMessageService from "../MessageServices/CreateMessageService";
import UploadHelper from "../../helpers/UploadHelper";
import fs from "fs";
import path from "path";
import { exec } from "child_process";
import { promisify } from "util";
import AudioConverter from "../../utils/AudioConverter";
import { shouldSendAsPTT, getMimetypeForFormat } from "../../config/audio.config";

const execAsync = promisify(exec);

interface Request {
  media: Express.Multer.File;
  ticket: Ticket;
}

const SendWhatsAppMedia = async ({
  media,
  ticket
}: Request): Promise<Message> => {
  console.log("üéµ SendWhatsAppMedia called with:", {
    mediaType: media.mimetype,
    fileName: media.originalname,
    fileSize: media.size,
    ticketId: ticket.id,
    ticketChannel: ticket.channel,
    contactNumber: ticket.contact.number
  });
  
  try {
    const wbot = await GetTicketWbot(ticket);
    
    // Verificar se o wbot est√° conectado
    if (!wbot || !wbot.user) {
      console.error("‚ùå WhatsApp bot not connected or user not available");
      throw new AppError("ERR_WAPP_NOT_CONNECTED");
    }
    
    console.log("‚úÖ WhatsApp bot connected, user:", wbot.user.id);

    // Determine message type based on media mimetype
    let messageContent: any;
    const mediaType = media.mimetype.split("/")[0];
    
    switch (mediaType) {
      case "image":
        const imageBuffer = fs.readFileSync(media.path);
        messageContent = {
          image: imageBuffer,
          caption: media.originalname
        };
        console.log("üñºÔ∏è Image buffer size:", imageBuffer.length, "bytes");
        break;
      case "video":
        const videoBuffer = fs.readFileSync(media.path);
        messageContent = {
          video: videoBuffer,
          caption: media.originalname
        };
        console.log("üé• Video buffer size:", videoBuffer.length, "bytes");
        break;
      case "audio":
        let finalAudioBuffer: Buffer;
        let finalMimetype: string;
        let convertedAudioPath: string | null = null;
        let audioFormat: string = 'unknown';
        let sendAsPTT: boolean = true; // Padr√£o: enviar como PTT
        
        try {
          console.log("üîÑ Iniciando processamento de √°udio com estrat√©gia iOS-compat√≠vel...");
          
          if (AudioConverter.isFFmpegAvailable()) {
            // NOVA ESTRAT√âGIA: Usar convers√£o com m√∫ltiplos formatos
            const tempBasePath = media.path.replace(path.extname(media.path), '_converted');
            const conversionResult = await AudioConverter.convertToPTTNew(media.path, tempBasePath);
            
            convertedAudioPath = conversionResult.path;
            finalMimetype = getMimetypeForFormat(conversionResult.format);
            audioFormat = conversionResult.format;
            
            // Verificar se a convers√£o foi bem-sucedida
            if (fs.existsSync(convertedAudioPath) && fs.statSync(convertedAudioPath).size > 0) {
              console.log(`‚úÖ Convers√£o ${audioFormat.toUpperCase()} conclu√≠da com sucesso`);
              finalAudioBuffer = fs.readFileSync(convertedAudioPath);
              
              // Determinar se deve enviar como PTT baseado na configura√ß√£o
              sendAsPTT = shouldSendAsPTT(audioFormat);
              console.log(`üì± Formato ${audioFormat.toUpperCase()}: ${sendAsPTT ? 'PTT (mensagem de voz)' : '√°udio normal'} baseado na configura√ß√£o`);
            } else {
              throw new Error('Convers√£o falhou - arquivo de sa√≠da inv√°lido');
            }
          } else {
            console.warn("‚ö†Ô∏è FFmpeg n√£o dispon√≠vel - usando arquivo original");
            console.warn("üí° Para melhor compatibilidade iOS, instale FFmpeg: npm install");
            
            // Usar arquivo original como fallback
            finalAudioBuffer = fs.readFileSync(media.path);
            finalMimetype = AudioConverter.getBestMimetype(media.path);
            audioFormat = 'original';
          }
        } catch (conversionError) {
          console.warn("‚ö†Ô∏è Audio conversion failed, using original format:", conversionError);
          
          // Fallback: usar o arquivo original com melhor mimetype
          finalAudioBuffer = fs.readFileSync(media.path);
          finalMimetype = AudioConverter.getBestMimetype(media.path);
          audioFormat = 'fallback';
          
          console.log("üì± Using fallback mimetype:", finalMimetype);
        }
        
        // Valida√ß√£o do buffer de √°udio
        if (!finalAudioBuffer || finalAudioBuffer.length === 0) {
          throw new Error("Buffer de √°udio est√° vazio ou inv√°lido");
        }
        
        if (!Buffer.isBuffer(finalAudioBuffer)) {
          throw new Error("finalAudioBuffer n√£o √© um Buffer v√°lido");
        }
        
        const audioSizeKB = (finalAudioBuffer.length / 1024).toFixed(1);
        console.log("üìä √Åudio processado:", {
          tamanho: `${audioSizeKB}KB`,
          formato: audioFormat,
          mimetype: finalMimetype,
          convertido: !!convertedAudioPath,
          enviarComoPTT: sendAsPTT
        });
        
        // Verificar se o arquivo n√£o est√° muito pequeno
        if (parseFloat(audioSizeKB) < 2) {
          console.warn(`‚ö†Ô∏è Arquivo muito pequeno (${audioSizeKB}KB) - pode causar problemas no iOS`);
        }
        
        // Configurar mensagem de √°udio
        if (sendAsPTT) {
          // Enviar como PTT (Push-to-Talk) - mensagem de voz
          messageContent = {
            audio: finalAudioBuffer,
            mimetype: finalMimetype,
            ptt: true
          };
          console.log("üé§ Mensagem configurada como PTT (mensagem de voz)");
        } else {
          // Enviar como √°udio normal - arquivo de √°udio
          messageContent = {
            audio: finalAudioBuffer,
            mimetype: finalMimetype,
            ptt: false
            // fileName: media.originalname // Opcional para √°udio normal
          };
          console.log("üéµ Mensagem configurada como √°udio normal (arquivo de √°udio)");
        }
        
        // Limpar arquivo tempor√°rio se foi criado
        if (convertedAudioPath && convertedAudioPath !== media.path) {
          // Agendar limpeza ap√≥s o envio
          setTimeout(() => {
            AudioConverter.cleanupTempFile(convertedAudioPath!);
          }, 5000); // 5 segundos ap√≥s o envio
        }
        break;
      default:
        messageContent = {
          document: { url: media.path },
          mimetype: media.mimetype,
          fileName: media.originalname
        };
    }

    // Construir o JID corretamente para grupos e contatos individuais
    const isGroup = ticket.contact.isGroup || ticket.contact.number.includes("-") || ticket.contact.number.endsWith("@g.us");
    let jid: string;
    
    if (ticket.contact.number.includes("@")) {
      jid = ticket.contact.number;
    } else {
      jid = `${ticket.contact.number}@${isGroup ? "g.us" : "s.whatsapp.net"}`;
    }

    // Verificar se o arquivo existe
    if (!fs.existsSync(media.path)) {
      console.error("‚ùå Audio file does not exist:", media.path);
      throw new AppError("ERR_AUDIO_FILE_NOT_FOUND");
    }
    
    // Preparar envio
    console.log("üöÄ Preparando envio para:", jid);
    
    // Enviar mensagem via Baileys
    console.log('üì§ Enviando mensagem...');
    
    const sentMessage = await wbot.sendMessage(jid, messageContent);
    
    console.log("‚úÖ Mensagem enviada com sucesso:", {
      id: sentMessage?.key?.id,
      status: sentMessage?.status
    });

    // Debug: verificar se sentMessage foi retornado corretamente
    if (!sentMessage || !sentMessage.key || !sentMessage.key.id) {
      console.error("Error: sentMessage or sentMessage.key.id is undefined", {
        sentMessage,
        hasKey: !!sentMessage?.key,
        hasId: !!sentMessage?.key?.id
      });
      throw new AppError("ERR_SENDING_WAPP_MSG: Invalid message response");
    }

    // Organizar arquivo por empresa e categoria
    const fileName = UploadHelper.generateFileName(media.originalname);
    const uploadConfig = {
      companyId: ticket.companyId,
      category: 'chat' as const,
      ticketId: ticket.id
    };

    let mediaPath: string;
    try {
      // Salvar arquivo no diret√≥rio organizado
      if (media.buffer) {
        mediaPath = await UploadHelper.saveBuffer(media.buffer, uploadConfig, fileName);
      } else {
        mediaPath = await UploadHelper.moveFile(media.path, uploadConfig, fileName);
      }
    } catch (err) {
      console.log("Error organizing media file:", err);
      throw new AppError("ERR_SAVING_MEDIA");
    }

    // Create message record in database
    const messageData = {
      id: sentMessage.key.id,
      ticketId: ticket.id,
      contactId: undefined, // fromMe messages don't have contactId
      body: "", // Deixar vazio para n√£o mostrar o nome do arquivo no chat
      fromMe: true,
      read: true,
      mediaType: mediaType,
      mediaUrl: mediaPath, // Usar caminho organizado
      ack: 1, // sent
      dataJson: JSON.stringify(sentMessage)
    };

    // Update ticket's last message with friendly description
    const lastMessageText = mediaType === 'image' ? 'üì∑ Imagem' : 
                           mediaType === 'video' ? 'üé• V√≠deo' : 
                           mediaType === 'audio' ? 'üéµ √Åudio' : 
                           'üìÑ Documento';
    await ticket.update({ lastMessage: lastMessageText });

    // Create message and emit socket event
    const newMessage = await CreateMessageService({ 
      messageData, 
      companyId: ticket.companyId 
    });

    return newMessage;

  } catch (err) {
    console.log("Error sending WhatsApp media:", err);
    throw new AppError("ERR_SENDING_WAPP_MSG");
  }
};

export default SendWhatsAppMedia;